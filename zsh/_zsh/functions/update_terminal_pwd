# update_terminal_pwd
# -------------------
#
# Identify the current working directory to the terminal emulator. To
# use, register as a chpwd or precmd hook:
#
#     fpath=(/wherever/this/file/lives $fpath)
#
#     # With add-zsh-hook (requires zsh 4.3.4 or later).
#     autoload -Uz add-zsh-hook
#     add-zsh-hook -Uz chpwd update_terminal_pwd
#
#     # Without add-zsh-hook.
#     autoload -Uz update_terminal_pwd
#     typeset -a chpwd_functions
#     chpwd_functions+=update_terminal_pwd
#
# Currently supports OS X's Terminal.app.


emulate -L zsh

# TODO: Figure out how to communicate terminal type via SSH.
[[ ${TERM_PROGRAM} == Apple_Terminal || -n ${SSH_TTY} ]] || return

# Adapted from:
#   - OS X's /etc/bashrc
#   - https://stackoverflow.com/a/187853/50102 (which is slightly
#     incorrect)
#   - https://timingapp.com/help/terminal

# Percent-encode the URI components. Non-intuitively, we must *disable*
# MULTIBYTE to correctly encode multibyte Unicode characters.
#
# For portability and robustness, use logname(1) instead of $LOGNAME or
# $USER [1][2].
#
# TODO: Implement some fallbacks for systems without hostname(1).
setopt EXTENDED_GLOB NO_MULTIBYTE
local encuser enchost encpath
{
    enchost=${"$(hostname)"//(#m)?/%$(([##16] ##${MATCH}))}
    if [[ -n $enchost ]]; then
        encuser=${"$(logname)"//(#m)?/%$(([##16] ##${MATCH}))}
    fi
} 2>/dev/null
encpath=${PWD//(#m)[^\/]/%$(([##16] ##${MATCH}))}
[[ -n $encpath ]] || return

# This OSC sequence is from Terminal.app's General Preferences.
local fmt='\e]7;%s\a'

# Inside tmux, wrap the sequence to pass it through (see
# https://mail-archive.com/tmux-users@lists.sourceforge.net/msg03485.html).
[[ -n $TMUX ]] && fmt='\ePtmux;\e'${fmt}'\e\'

# Assemble URI and print complete sequence to the terminal emulator.
printf $fmt file://${encuser:+${encuser}@}${enchost}${encpath}


# References
#   1. https://pubs.opengroup.org/onlinepubs/9699919799/utilities/logname.html
#   2. https://unix.stackexchange.com/a/76369/2803

# vim: set filetype=zsh:
